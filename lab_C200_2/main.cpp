// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.

#include "header.h"
#include "union.h"
#include "class.h"


#define	  stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{

	
	//Задание 1.Массив объектов класса.
	{
	//Объявите и проинициализируйте массив ar из объектов типа MyString. 
		
		//const int N = 3; 
		const int N = 5;
		MyString str1[N] = {MyString ("ABC"), MyString("BCD"), MyString("EFG")};
		stop
		//Проверка - печать строк-членов класса
		for (size_t i = 0; i < N; i++)
		{
			cout << str1[i].GetString() << endl;
		}
		stop
	
	//Замените размер const int N=5; , не изменяя список инициализаторов.
	
	//при появлении неинициализированных членов массива компилятор создат неименнованные объекты и вызовет дефолтный конструктор 

			
	}
	stop


	//Задание 2.Массив указателей на объекты класса.
	{
	//Объявите и проинициализируйте массив arPtr из N
	//указателей на объекты типа MyString (сами объекты 
	//создаются динамически!).
	//const int N=3;
	const int N = 5;
	MyString* arPtr[N] = { new MyString("One"), new MyString("Two"), new MyString("Three") };

	//Печать строк-членов класса
	for (size_t i = 0; i < N; i++)
	{
		cout << arPtr[i]->GetString() << endl;
	}
	stop
	//Замените размер const int N=5; , не изменяя список инициализаторов.

	//при изменении размера массива, 4-й и 5-й эелемент инициализированы нулем. 
	}
	
	//Задание 3.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.
	
	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
	{
		Shape Sample(BLUE);
		stop
		Rect Square(1, 2, GREEN);
		stop
		Circle Ring(2, RED);
		stop
	}
	stop
	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов
	
	stop
	
//////////////////////////////////////////////////////////////////////

	//Задание 4.Виртуальные функции.
	//4а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.


	{
		Shape s(BLUE);
		Rect r(1,2,GREEN);
		Circle c(2,RED);

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	невирутальный метод класса Shape
		stop
		r.WhereAmI();	//	невиртуальный метод класса Rect
		stop
		c.WhereAmI();	//	невирутальный метод класса Circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	//	невирутальный метод класса Shape
		stop
		pRect->WhereAmI();	//	невирутальный метод класса Shape
		stop
		pCircle->WhereAmI(); //	невиртуальный метод класса Shape
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
		
    	rShape.WhereAmI();	//вызов посредством rShape	невиртуальный метод класса Shape
		stop
		rRect.WhereAmI();	//вызов посредством	rRect	невиртуальный метод класса Shape
		stop
		rCircle.WhereAmI(); //вызов посредством rCircle	невиртуальный метод класса Shape
		stop
	}

	//4б) Добавьте в базовый и производные классы виртуальный
	// метод WhereAmIVirtual(). По аналогии с 4а вызовите
	// виртуальный метод посредством объектов, указателей и
	// ссылок, определенных в предыдущем фрагменте.
	//Выполните новый фрагмент, объясните разницу.

	{
		Shape s(RED);
		Rect r(1, 2, BLUE);
		Circle c(2, GREEN);
		stop

		s.WhereAmIVirtual(); //виртуальный метод класса Shape
		r.WhereAmIVirtual(); //виртуальный метод класса Rect
		c.WhereAmIVirtual(); //виртуальный метод класса Circle
		stop

		Shape* pShare = &s;
		Rect* pRect = &r;
		Circle* pCircle = &c;

		Shape* arShape[] = { pShare, pRect,pCircle };
		for (size_t i = 0; i < sizeof(arShape)/sizeof(Shape*); i++)
		{
			arShape[i]->WhereAmIVirtual();
		}

		stop
		Shape& refShare = s;
		Rect& refRect = r;
		Circle& refCircle = c;
		
		refShare.WhereAmIVirtual(); //виртуальный метод класса Shape
		refRect.WhereAmIVirtual();  //виртуальный метод класса Rect
		refCircle.WhereAmIVirtual();//виртуальный метод класса CIrcle
		stop
	}
			

	
//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.
	//{
	//	Shape s(RED);					//в этой области видимости деструктор вызыватся корректно. Сначала деструкторы производных классов, затем базового.
	//	Rect r(1, 2, BLUE);
	//	Circle c(2, GREEN);
	//	stop
	//}
	{
																						// в этой области видимости деструкторы невирутальные вызываются некорректно, так как у нас массив
		Shape* arShape[] = { new Shape(RED), new Rect(1,2,BLUE), new Circle(2,GREEN) };	//указателей типа базового класса и производные части освобождаются некорректно, вызывается базовый деструктор
		for (size_t i = 0; i < sizeof(arShape)/sizeof(Shape*);  i++)					//в объекте Rect дважды вызовется Shape деструктор
		{
			delete arShape[i];
		}
	}
	stop
	// b) Добавьте в объявление деструкторов ключевое слово virtual							//если деструктор виртуальный, вызов корректный. Сначала деструктор производного, затем базового класса
	//Выполните фрагмент.Объясните разницу.

	
	//Подумайте: какие конструкторы вызываются в следующей строке?
	//Если в разработанных классов каких-то конструкторов
	//не хватает - реализуйте
	//Если Вы считаете, что в приведенном фрагменте чего-то
	//не хватает - добавьте

		Rect r(1,2,BLUE); 

		Shape* ar[]={new Shape(r), new Rect(r),new Circle(r), new Circle()};					//new Shape(r) вызван Shape конструктор копирования
		//Вызовите для каждого элемента массива метод WhereAmIVirtual()							//new Rect(r) вызван Shape, затем Rect конструктор копирования 
		stop																					//new Circle(r) вызван Shape, затем перегруженный Circle конструктор копирования
		for (size_t i = 0; i < sizeof(ar)/sizeof(Shape*); i++)									//new Circle() вызван Shape, затем Circle дефолтный конструктор копирования
		{
			ar[i]->WhereAmIVirtual();
		}
		stop
		for (size_t i = 0; i < sizeof(ar)/sizeof(Shape*); i++)									//new Circle() вызван Shape, затем Circle дефолтный конструктор копирования
		{
			delete ar[i];
		}

	//Задание 6*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[2];	//1) Указатель базового типа на динамический массив из 10 элементов типа Rect
		stop
		Rect* pRects = new Rect[2];		//2) Указатель производного типа на динамический массив из 10 элементов типа Rect
		stop
		//Попробуйте вызвать метод WhereAmIVirtual() для каждого элемента обоих массивов -
		//в чем заключается проблема???

		for (size_t i = 0; i < 2; i++)									
		{
			static_cast<Rect*>(pShapes)[i].WhereAmIVirtual();	//метод виртуальный, так как объект типа Rect, несмотря на то что указатель базового типа, вызовется метод производного класса
		}														//на второй итерации, ошибка памяти, на второй итерации указатель сдвигается на sizeof(shape), а элементы массива типа Rect
																//кастуем указатель типа Shape в Rect
		stop
		
		
		for (size_t i = 0; i < 2; i++)
			{
				pRects[i].WhereAmIVirtual();					//вызывается вируальный метод класса Rect
			}
		stop
			
		//Освободите динамически захваченную память
		delete[] pShapes;
		delete[] pRects;
	}

	

//////////////////////////////////////////////////////////////////////

	//Задание 7.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(1,2,BLUE);
		Shape* p = &r;	
		p->WhereAmIVirtual();			// вызван вирутальный метод класса Rect
		stop


		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmIVirtual()класса Shape 
		r.Shape::WhereAmIVirtual();		//вызвали виртуальный метод базового класса посредством объекта
		p->Shape::WhereAmIVirtual();	//вызвали виртуальный метод базового класса посредствои указателя
		stop		
	}

	
//////////////////////////////////////////////////////////////////////

	//Задание 8.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		Rect r(1,2,BLUE);		//чисто виртуальный метод не реализовать, базовый класс станет прототипом. Создавать подобный объет нельзя, только использовать для релизации
		Shape* p = &r;			//производных классов
		p->Inflate(5);
		stop
		Circle c(2,GREEN);
		p = &c;
		p->Inflate(5);
		stop
	}

	

//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров

MyString str_res = StringСoncatenation("ABC", "DEF","GHI",0);
stop
std::cout<<str_res.GetString()<<std::endl;
stop
////////////////////////////////////////////////////////////////////////

	//Задание 10.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

MyByte byte(0x1f);
	stop

	byte.ShowBin();
	byte.ShowBinPos(6);
	byte.EditBin(1, 5);
	stop

	byte.ShowOct();
	byte.ShowOctPos(1);
	byte.EditOct(1, 5);
	stop

	byte.ShowHex();
	byte.ShowHexPos(1);
	byte.EditHex(1, 5);
	stop
	
	byte.ShowDec();
	stop

	byte.ShowChar();
	stop
	
	return 0;
}//endmain

