#include "myRect.h"
#include "myString.h"
#include "myBochka.h"
#include <iostream>

#define stop __asm nop

int main()
{
	using namespace std;
	
	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect;
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	Rect rect_1(1, 2, 3, 4);

	stop

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom
		//Подсказка: учтите, что пользователь Вашего класса может указывать
		//в качестве параметров любые значения! Например:

		Rect rrr(4, 3, 2, 1);


	stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

		Rect rect_null_value;

	stop

		//1в. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

		rect_1.InflateRect(2, 3, 4, 5);

	stop


		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
	Rect r1;									// вызван конструктор с параметрами по умолчанию

	Rect r2(1, 2, 3, 4);						// вызван конструктор с параметрами пользователя

	Rect r3 = r1;								// вызван конструктор копирования

	Rect r4(r2);								// вызван конструктор копирования

	stop


	//2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
	r1.InflateRect(1, 1);						// вызван перегруженный метод принимающий два параметра из объекта r1 типа Rect

	r2.InflateRect(2, 2);						// вызван перегруженный метод принимающий два параметра из объетка r2 типа Rect

	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
	r3.InflateRect(2, 2, 2, 2);					// вызван перегруженный метод принимающий ЧЕТЫРЕ параметра из объекта r3 типа Rect

	r3.InflateRect(3, 3);						// вызван перегруженный метод принимающий ДВА параметра из объекта r3 типа Rect

	r3.InflateRect(5);							// вызван перегруженный метод принимающий ДВА параметра из объекта r3 типа Rect, в функцию передано только одно значение, сработал один параметр по умолчанию

	r3.InflateRect();							// вызван перегруженный метод принимающий ДВА параметра из объекта r3 типа Rect, в функцию не передано значений, оба параметра по умолчанию

	stop



		//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left;			// ошибка возникла из права доступа private, переменную не видно извне



	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	r.SetAll(5, 4, 3, 2);																				// вызвали public метод объекта r типа Rect, ввели значения в переменные

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
	int value_m_left = 0, value_m_right = 0, value_m_right_m_top = 0, value_m_right_m_bottom = 0;

	r.GetAll(value_m_left, value_m_right, value_m_right_m_top, value_m_right_m_bottom);					// вызвали public метод объекта r типа Rect принимающий ссылки на переменные и присвоили этим переменным значения из объекта 

	stop
	}

		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования. 
		//Создайте глобальную функцию 
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

	{
		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;
		r3 = BoundingRect(r1, r2);
		stop


			//Задание 4а. Передача объектов по ссылке.
			//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
			//задачу, принимая параметры по ссылке
			//Вызываются ли конструкторы при передаче параметров?

			r3 = BoundingRect2(r1, r2);
		stop


			//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса
			r3 = r3.BoundingRect(r1, r2);
		stop
	}

	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;							// объявлен объект типа Rect, вызван конструктор со значениями по умолчанию, деструктор будет вызван на 191 стр.

		Rect* pR = new Rect(1, 2, 1, 2);		// выделено место в хипе под объект типа Rect, вызван конструктор с параметрами, деструктор необходимо вызвать руками
		{
			Rect r2(r1);					// объявлен объект r2 типа Rect, вызван конструктор копирования (функциональная форма записи // Rect r2=r1;),деструктор вызвали руками на 186 строке

			Rect arRect[2];					// объявлен массив из двух элементов типа Rect, вызван конструктор со значениями по умолчанию, деструктор будет вызван на 187 стр.
			for (int i = 0; i < 3; i++)
			{
				static Rect r3(i, i, i, i);	// объявлен объет r3 типа Rect,вызван конструктор с параметрами, место выделено в статической памяти, конструктор вызвыается только на первой итерации, деструктор вызовется по выходу из программы // 0 0 0 0
				Rect r4(*pR);				// локальный объект r4 типа Rect, вызван конструктор копирования,объект в динамической памяти, место выделено в локальной памяти, конструктор вызывается на каждой итерации, деструктор вывзвается на выходе из цикла // 1 2 1 2
				Rect r5(i, i, i, i);			// локальный объект r5 типа Rect, вызван конструктор с параметрами,место выделено в локальной памяти, конструктор вызывается на каждой итерации, деструктор вывзвается на выходе из цикла // i++
				stop
			}
			stop
				r2.~Rect();					// вызвали деструктор для объекта r2
		}

		delete pR;	// вызван деструктор динамически выделенного объекта
		stop
	}

	
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str1("It's my string1!");
		MyString str_default;
		stop
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str1
		//Замечание: подумайте, как следует корректно реализовать метод GetString().

		//Подсказка 1:
		//приведенный ниже код должен работать:
		std::cout << str1.GetString() << std::endl;
		stop
			
		//Подсказка 2:
		//приведенный ниже код НЕ должен работать:
		//str1.GetString()[1] = 'W';

		//Подсказка 3:
		//приведенный ниже код должен работать:
		const MyString	str2("It's my string2!");
		std::cout << str2.GetString() << std::endl;
		stop
	}


		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
	{
		MyString str1("The first string!");
		MyString str2 = str1;
	}
	stop

		//6б. Реализуйте метод SetNewString, который будет заменять строку
		// на новую
	{
	MyString str("Original string");
	std::cout << str.GetString() << std::endl;
	str.SetNewString("New string");
	std::cout << str.GetString() << std::endl;
	stop
	}

	//Задание 7.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Bochka spirt(100,96);
	Bochka water(100,0);
	double target_concentration=spirt.GetSpirtConcentration();
	int iteration = 0;
	while(target_concentration>50)
		{
		water.Pereliv(spirt, 1);
		spirt.Pereliv(water, 1);
	
	iteration++;
	target_concentration = spirt.GetSpirtConcentration();
	//		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
	//		water.Pereliv(spirt); // аналогично
	//		...
	} 
	stop
return 0;

}//end_main

